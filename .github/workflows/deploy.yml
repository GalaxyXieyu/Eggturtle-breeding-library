name: Build and Deploy

on:
  push:
    branches: [main]
  workflow_dispatch:

env:
  IMAGE_NAME: ${{ vars.IMAGE_NAME || 'eggturtles' }}
  K8S_NAMESPACE: ${{ vars.K8S_NAMESPACE || 'ns-lmgpb9nc' }}
  K8S_WORKLOAD_NAME: ${{ vars.K8S_WORKLOAD_NAME || 'eggturtles' }}
  K8S_WORKLOAD_KIND: ${{ vars.K8S_WORKLOAD_KIND || 'auto' }}
  K8S_CONTAINER_NAME: ${{ vars.K8S_CONTAINER_NAME || 'eggturtles' }}

  # This repo deploys on Postgres + MinIO (stateless). PVC guard is only for sqlite(/data/app.db) legacy.
  REQUIRE_DATA_PVC: ${{ vars.REQUIRE_DATA_PVC || 'false' }}

  # Run schema migrations before rolling out new image. Uses the same env as the workload (no secrets in Actions).
  RUN_DB_MIGRATIONS: ${{ vars.RUN_DB_MIGRATIONS || 'true' }}
  DB_MIGRATION_COMMAND: ${{ vars.DB_MIGRATION_COMMAND || 'pnpm --filter @eggturtle/api prisma:deploy' }}

jobs:
  verify:
    runs-on: ubuntu-latest

    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Set up Node
        uses: actions/setup-node@v4
        with:
          node-version: '22'

      - name: Enable corepack
        run: corepack enable

      - name: Install deps
        run: pnpm install --frozen-lockfile

      - name: Lint
        run: pnpm -r lint

      - name: Build
        run: pnpm -r build

  build-and-push:
    runs-on: ubuntu-latest
    needs: verify

    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Set up Docker Buildx
        uses: docker/setup-buildx-action@v3

      - name: Login to Docker Hub
        uses: docker/login-action@v3
        with:
          username: ${{ secrets.DOCKERHUB_USERNAME }}
          password: ${{ secrets.DOCKERHUB_TOKEN }}

      - name: Build and push Docker image
        uses: docker/build-push-action@v5
        with:
          context: .
          file: Dockerfile.node
          platforms: linux/amd64
          push: true
          tags: |
            ${{ secrets.DOCKERHUB_USERNAME }}/${{ env.IMAGE_NAME }}:latest
            ${{ secrets.DOCKERHUB_USERNAME }}/${{ env.IMAGE_NAME }}:${{ github.sha }}
          cache-from: type=gha
          cache-to: type=gha,mode=max
          outputs: type=docker

  deploy:
    runs-on: ubuntu-latest
    needs: build-and-push

    steps:
      - name: Set up kubectl
        uses: azure/setup-kubectl@v4
        with:
          version: 'latest'

      - name: Deploy to Sealos
        env:
          KUBE_CONFIG_CONTENT: ${{ secrets.KUBE_CONFIG }}
        run: |
          set -euo pipefail

          mkdir -p ~/.kube
          # 兼容两种 Secret 存法：
          # 1) 直接存 kubeconfig YAML（推荐）
          # 2) 存 base64 后的 kubeconfig（需确保是未换行的单行 base64）
          if printf '%s' "$KUBE_CONFIG_CONTENT" | tr -d '\r' | base64 -d > ~/.kube/config 2>/dev/null; then
            echo "kubeconfig loaded from base64 secret"
          else
            printf '%s' "$KUBE_CONFIG_CONTENT" | tr -d '\r' > ~/.kube/config
            echo "kubeconfig loaded from raw yaml secret"
          fi

          WORKLOAD_KIND="${K8S_WORKLOAD_KIND}"
          WORKLOAD_NAME="${K8S_WORKLOAD_NAME}"
          NAMESPACE="${K8S_NAMESPACE}"
          CONTAINER_NAME="${K8S_CONTAINER_NAME}"
          IMAGE_REF="${{ secrets.DOCKERHUB_USERNAME }}/${{ env.IMAGE_NAME }}:${GITHUB_SHA}"

          echo "Deploy context: $(kubectl config current-context)"
          echo "Deploy namespace: ${NAMESPACE}"

          if [ "$WORKLOAD_KIND" = "auto" ]; then
            if kubectl get deployment/"$WORKLOAD_NAME" -n "$NAMESPACE" >/dev/null 2>&1; then
              WORKLOAD_KIND="deployment"
            elif kubectl get statefulset/"$WORKLOAD_NAME" -n "$NAMESPACE" >/dev/null 2>&1; then
              WORKLOAD_KIND="statefulset"
            else
              echo "::error::No deployment/statefulset named '$WORKLOAD_NAME' in namespace '$NAMESPACE'"
              echo "Available workloads:"
              kubectl get deploy,sts -n "$NAMESPACE" || true
              exit 1
            fi
          fi

          if [ "$WORKLOAD_KIND" != "deployment" ] && [ "$WORKLOAD_KIND" != "statefulset" ]; then
            echo "::error::K8S_WORKLOAD_KIND must be 'deployment', 'statefulset', or 'auto'"
            exit 1
          fi

          if [ -z "$CONTAINER_NAME" ]; then
            CONTAINER_NAME=$(kubectl get "$WORKLOAD_KIND"/"$WORKLOAD_NAME" -n "$NAMESPACE" -o jsonpath='{.spec.template.spec.containers[0].name}')
          fi
          if [ -z "$CONTAINER_NAME" ]; then
            echo "::error::Cannot resolve container name for $WORKLOAD_KIND/$WORKLOAD_NAME"
            exit 1
          fi

          if [ "${REQUIRE_DATA_PVC}" = "true" ]; then
            echo "Checking /data persistence guard..."
            MOUNT_ROWS=$(kubectl get "$WORKLOAD_KIND"/"$WORKLOAD_NAME" -n "$NAMESPACE" \
              -o jsonpath="{range .spec.template.spec.containers[?(@.name=='$CONTAINER_NAME')].volumeMounts[*]}{.name}:{.mountPath}{'\n'}{end}")

            DATA_VOLUME_NAME=$(printf '%s\n' "$MOUNT_ROWS" | awk -F: '$2=="/data" || $2=="/data/app.db"{print $1; exit}')
            if [ -z "$DATA_VOLUME_NAME" ]; then
              echo "::error::Missing /data volumeMount for $WORKLOAD_KIND/$WORKLOAD_NAME container=$CONTAINER_NAME. Refusing deploy to prevent sqlite data loss."
              echo "Current volumeMounts:"
              printf '%s\n' "$MOUNT_ROWS"
              exit 1
            fi

            PVC_NAME=$(kubectl get "$WORKLOAD_KIND"/"$WORKLOAD_NAME" -n "$NAMESPACE" \
              -o jsonpath="{.spec.template.spec.volumes[?(@.name=='$DATA_VOLUME_NAME')].persistentVolumeClaim.claimName}")

            if [ -z "$PVC_NAME" ]; then
              echo "::error::Volume '$DATA_VOLUME_NAME' is not backed by persistentVolumeClaim. Refusing deploy."
              kubectl get "$WORKLOAD_KIND"/"$WORKLOAD_NAME" -n "$NAMESPACE" -o yaml | sed -n '1,220p'
              exit 1
            fi

            PVC_PHASE=$(kubectl get pvc "$PVC_NAME" -n "$NAMESPACE" -o jsonpath='{.status.phase}')
            if [ "$PVC_PHASE" != "Bound" ]; then
              echo "::error::PVC '$PVC_NAME' phase=$PVC_PHASE (expected Bound). Refusing deploy."
              kubectl get pvc "$PVC_NAME" -n "$NAMESPACE" -o yaml | sed -n '1,220p'
              exit 1
            fi

            echo "PVC guard passed: volume=$DATA_VOLUME_NAME pvc=$PVC_NAME phase=$PVC_PHASE"
          else
            echo "Skipping /data PVC guard (REQUIRE_DATA_PVC=${REQUIRE_DATA_PVC})"
          fi

          if [ "${RUN_DB_MIGRATIONS}" = "true" ]; then
            echo "Running DB migrations via Job (from workload template)..."

            SHORT_SHA="${GITHUB_SHA:0:7}"
            MIGRATE_JOB="${WORKLOAD_NAME}-dbmig-${SHORT_SHA}"

            # Create a Job using the workload pod template so it inherits env (PG/MinIO creds) without putting secrets in Actions.
            kubectl get "$WORKLOAD_KIND"/"$WORKLOAD_NAME" -n "$NAMESPACE" -o json \
              | jq --arg job "$MIGRATE_JOB" \
                    --arg image "$IMAGE_REF" \
                    --arg container "$CONTAINER_NAME" \
                    --arg cmd "${DB_MIGRATION_COMMAND}" \
                    '{
                      apiVersion: "batch/v1",
                      kind: "Job",
                      metadata: {
                        name: $job,
                        labels: {
                          "app.kubernetes.io/name": "db-migrate",
                          "app.kubernetes.io/part-of": "eggturtles"
                        }
                      },
                      spec: {
                        backoffLimit: 0,
                        ttlSecondsAfterFinished: 600,
                        template: {
                          metadata: (.spec.template.metadata // {}),
                          spec: (
                            .spec.template.spec
                            | .restartPolicy = "Never"
                            | .containers = [
                                (.containers[]
                                  | select(.name == $container)
                                  | .image = $image
                                  | .command = ["sh", "-lc", $cmd]
                                  | del(.ports, .livenessProbe, .readinessProbe, .startupProbe)
                                )
                              ]
                          )
                        }
                      }
                    }' \
              | kubectl apply -n "$NAMESPACE" -f -

            kubectl wait --for=condition=complete job/"$MIGRATE_JOB" -n "$NAMESPACE" --timeout=900s
            kubectl logs job/"$MIGRATE_JOB" -n "$NAMESPACE" || true
          else
            echo "Skipping DB migrations (RUN_DB_MIGRATIONS=${RUN_DB_MIGRATIONS})"
          fi

          echo "Updating workload image and rolling out..."
          kubectl set image "$WORKLOAD_KIND"/"$WORKLOAD_NAME" "$CONTAINER_NAME"="$IMAGE_REF" -n "$NAMESPACE"
          kubectl rollout status "$WORKLOAD_KIND"/"$WORKLOAD_NAME" -n "$NAMESPACE" --timeout=600s
